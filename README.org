#+title: My Emacs configuration
#+options: toc:nil

* Early init

Here I set some variables that influence the startup process.
The reason I maximize the frame and set the background color early is to avoid a resizing window and white screen to blink on startup.
Last I clean up some vanilla default modes.

Emacs will run fine without the early-init but will have ugly defaults.

* Theme

I don't use a theme package.
I simply change faces if I don't like them.

I use (set-face-attribute...) because stuff set by (custom-set-faces...) is hard to change for packages I might load in the future (red text can be hard to read on a red background).
I don't like or use custom.el.

I restrict myself to use 8 warm dark theme colors.
Examples of their use are:
| Color | Use            |   | Color | Use            |   | Color | Use             |
|-------+----------------+---+-------+----------------+---+-------+-----------------|
| #bba  | default text   |   | #09f  | link/timestamp |   | #0f9  | comment/tags    |
| #332  | shadow/hl-line |   | #9f0  | success/done   |   | #f90  | warning/heading |
| #221  | background     |   | #f09  | error/todo     |   | #90f  | not used        |
|-------+----------------+---+-------+----------------+---+-------+-----------------|
Unspecified faces are handled by the vanilla theme.

When I configure evil I add 8 colors reserved for the cursor.
I tax the eyes a bit with extreme colors to help keeping track of the evil state and cursor placement.
| Color | State    |   | Color | State   |   | Color | State  |
|-------+----------+---+-------+---------+---+-------+--------|
| #f00  | Operator |   | #0ff  | Emacs   |   | #fff  | Visual |
| #0f0  | Normal   |   | #f0f  | Replace |   | #000  | Region |
| #00f  | Motion   |   | #ff0  | Insert  |   |       |        |
|-------+----------+---+-------+---------+---+-------+--------|
Operator state is red to alert.
Normal state has the opposite green color.
Insert state is the last trafic light color (yellow) and use a bar.
Replace state has the opposite color of insert state and use an hbar.
Emacs and motion states have the remaining rgb colors.

"Input" states have the "brighter" colors (with 2 f's) and bars in common.
The visual state is hollow and might be filled with the region color.

* Modeline

I don't use a package for my modeline either.
It consist of a window number, information about writable/modified status, the buffer name and the major mode.

The active window have some more information.
The information is git status and whether the buffer is narrowed.
Besides that the active window have the relative vertical position and column number after a gap.

Prot has a Youtube video on how to make your own modeline: [[https://www.youtube.com/watch?v=Qf_DLPIA9Cs][Emacs: write custom mode line]].

* Vanilla variables

Here I set variables that are used by vanilla Emacs or a native package.
I also activate a few native global minor modes.

* Custom functions

I keep these functions very simple.
Emacs usually provide what I need without me having to write a function.

I have a few functions that simply open some key files with find-file.
Then I have one to open my custom agenda and one does my idea capture.
Last I code some window manipulation, a git stage/commit and a save/quit without a prompt.

* Package.el

I use package.el and (require 'xyz) to install and load packages.
I used to use use-package but that seem to increase the number of garbage collections significantly (about 5 fold for me).
It is not clear to me that gains from controlling when to load packages (:defer) is worth this cost.
Deferring might also make debugging harder.
You might have to ask yourself is or isn't this or that loaded, when did it happen and is that what is causing the problem right now?
It's easier and cleaner to just have everything loaded.

Use-package/straight also have some other advantages like updating packages directly from a git repo, but I don't use that.
I preserve some of the structure that is also one of the features of use-package.
That means that I will set variables associated with a package just before I require it.
This would typically be part of an :init or :custom section in use-package.
Hooks (:hook or :config) and mode activations (:init?! or :config) I do right after require.
I do keybindings (:bind or :command) and faces (:custom-face) at the end of the configuration in dedicated sections.

All this should make it fairly easy to convert my config to use use-package or straight.

* Evil

This is the first of the 3 big packages (evil, org and general) I will comment on.

** Layered versus modal bindings

Emacs comes with a complex but very powerful set of /layered/ keybindings (using =<ctrl>=, =<meta>=, =<shift>= or combinations of these).
An alternative is the evil package with Vim's /modal/ keybindings combined with some layering.
I prefer modal bindings and try to minimize the use of layers.

** Cursor model (my sacrilege)

Besides the modal approach Vim has a unique cursor model.
When in insert state it works with the standard cursor between characters approach that all other editors use.
In normal state this model is changed to something no other editor I know have picked up on.
The cursor is considered on characters rather than between them.

I chose to use a modification of evil where the cursor is between characters in normal state.
This has the advantage of fewer keys being used (e.g. no need for =a=) at little to no cost in efficiency.

You might want to rebind some keys but with few exceptions I just leave the evil bindings be.
I do swap the two paste bindings =p= and =P= to avoid using the capitalized one.

** Two ways of pasting

I will try to illustrate this with a case study on pasting.
Vim's cursor on character model requires two ways of pasting.
One is layered with =<shift>= and really counts as two keystrokes.
You can mimic this behavior by using a "correction-motion" before paste in the cursor between characters model.
This means that from a strict efficiency perspective it is not clear what is gained from two paste commands.

This does not mean that Vim's way of doing things is inferior.
You should minimize "correction-motions", so you can go directly for Vim's "verb" -> "noun" approach as often as you can.
On the other hand you end up with the more complex two paste commands where only one is really necessary.
The more complex keybindings will only be an advantage to a power user.
As you get used to the less complex bindings you will develop foresight to use less "correction-motions".

** Casual use

As a more casual or inexperienced user, one paste command is preferable.
The cursor model will be more consistent both on it's own but also with other programs.
If you dislike layers and try to minimize their use, you gain a lot from not needing capitalized bindings.
I very much dislike holding down two keys at once just as if I were using vanilla Emacs (take that Vim out of the box lovers).

In my configuration the between characters behavior is isolated in evil-cursor-model.el which I have slightly modified compared to [[https://www.dr-qubit.org/Evil_cursor_model.html][the author's version]].
Standard evil behavior is easy to achieve by simply not loading that file.

* Misc. packages

I use a large number of packages.
Besides evil, org and general honorable mentions are vertico, corfu, ace-window, recursive-narrow and magit.

* Org-mode

I customize this native package with a large set of variables.
I extend it with a few external packages, the native prettify.el and a few hooks.

** Org-agenda

I restrict myself to only 4 todo-states (NEXT, TODO, HOLD and DONE).
The only state I feel I need to explain is HOLD which is an inactive state that can be translated to "pending third party action".
Besides the states I use refile and an unrestricted number of categories for todo items.
Some might want a canceled state, but I cancel items by archiving them in an active state.

I carefully configure my custom agenda and capture but will not elaborate further on them here.
I humbly claim that my code is probably worth a read, if you want to customize your agenda.

* General.el

As with my theme and modeline I could and perhaps should do my leader key keybindings with "-maps", but I'm not there yet.
Prot has a nice Youtube video about it: [[https://www.youtube.com/watch?v=gojOZ3k1mmk][Emacs: define prefix/leader key]].

For now I use general.el to handle my leader keybindings.
Inspired by Spacemacs I use =<SPC>= as my leader key and part of the structure in my leader keybindings are also inspired by this project.

* Keybindings

I like to have all my keybindings in a section rather than distributed out among my packages.
I find it more useful to spot collisions by gathering these bindings in one place.
Use-package might be able to defer stuff based on :bind but I don't use use-package.

A few evil bindings specific to the change in cursor model are modified inside evil-cursor-model.el.

* Package faces

Here I specify faces used by packages.
I typically use (with-eval-after-load...) and this can be used to identify in what package the face is introduced.

* Vanilla hooks

I end my configuration of with a few hooks that are not tied to external packages.
